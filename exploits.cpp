#include "globals.hpp"
#include "exploits.hpp"
#include "anti_aim.hpp"
#include "threads.hpp"
#include "engine_prediction.hpp"
#include "animations.hpp"
#include "server_bones.hpp"
#include "ragebot.hpp"
#include "cmd_shift.hpp"
#include "fake_lag.hpp"
#include "predfix.hpp"

#ifndef _DEBUG
#include <VirtualizerSDK.h>
#endif

void c_tickbase::store(int tickbase, int cmd, int shift, bool restore, int cmd_diff)
{
	auto& d = data;
	d.tickbase = tickbase;
	d.command_number = cmd;
	d.shift_amount = shift;
	d.restore_tickbase = restore;
	d.cmd_diff = cmd_diff;
}

void c_tickbase::fix(int new_command_number, int& tickbase)
{
	auto& d = data;
	if (d.command_number <= 0)
		return;

	auto viewmodel = (c_base_entity*)(HACKS->entity_list->get_client_entity_handle(HACKS->local->viewmodel()));
	if (!viewmodel)
		return;

	if (d.command_number == new_command_number)
	{
		viewmodel->anim_time() -= TICKS_TO_TIME(d.shift_amount + HACKS->global_vars->sim_ticks_this_frame);
		tickbase = d.tickbase - d.shift_amount + HACKS->global_vars->sim_ticks_this_frame;
	}

	if (d.restore_tickbase && d.command_number + d.cmd_diff == new_command_number)
	{
		viewmodel->anim_time() += TICKS_TO_TIME(d.shift_amount - HACKS->global_vars->sim_ticks_this_frame);
		tickbase += d.shift_amount - HACKS->global_vars->sim_ticks_this_frame;
	}
}

int c_exploits::get_instance_mode()
{
	if (ANTI_AIM->is_fake_ducking() || g_cfg.binds[fd_b].toggled)
		return EXPLOITS_NONE;

	if (g_cfg.binds[dt_b].toggled)
		return EXPLOITS_DT;

	if (g_cfg.binds[hs_b].toggled)
		return EXPLOITS_HS;

	return EXPLOITS_NONE;
}

bool c_exploits::should_recharge()
{
	if (!available)
		return false;

	static int choke{};

	if (recharge.start && !choke)
	{
		if (recharge.charge_ticks <= 0)
		{
			recharge.start = false;
			recharge.finish = true;
			recharge.last_charge_tick = HACKS->cmd->command_number;

			return false;
		}

		recharge.finish = false;
		--recharge.charge_ticks;
		execute_shift = false;

		return true;
	}
	else
		choke = HACKS->client_state->choked_commands;

	return false;
}

void c_exploits::update_exploit_mode()
{
	if (!this->available)
	{
		this->recharge.reset();
		return;
	}

	auto instance_mode = this->get_instance_mode();
	if (this->current_mode != instance_mode)
	{
		auto& recharge = this->recharge;
		if (instance_mode == EXPLOITS_NONE)
		{
			if (!this->in_action && this->enabled())
			{
				auto& cl_move = this->cl_move;
				cl_move.trigger = true;
				cl_move.shifting = false;
				cl_move.complete = false;
				cl_move.amount = this->limits.double_tap - 1;
			}

			recharge.reset();
			this->reset_dt = false;

			this->tick_to_shift_before = 0;
			this->dt_bullet = 0;
			this->current_mode = instance_mode;
		}
		else
		{
			if (!recharge.start && !recharge.finish)
			{
				recharge.start = true;
				recharge.finish = false;
				recharge.charge_ticks = this->limits.recharge;
				recharge.fix_tickbase = true;

				this->in_action = false;
				this->reset_dt = false;
				this->dt_bullet = 0;
			}

			this->current_mode = instance_mode;
		}
	}
}

inline bool is_peeking_for_exploits()
{
	return ANTI_AIM->is_peeking();
}

void c_exploits::update_instance()
{
	available = !(HACKS->local->flags().has(FL_FROZEN)) && !HACKS->local->has_gun_game_immunity();

	auto threaded_peeking = THREAD_POOL->add_task(is_peeking_for_exploits);
	auto result = std::any_cast<bool>(THREAD_POOL->wait_result(threaded_peeking));

	auto& best_player = RAGEBOT->best_rage_player;
	HACKS->can_peek = result;

	limits.update();
	update_exploit_mode();

	if (!g_cfg.binds[ap_b].toggled)
		RAGEBOT->firing = false;
}

void c_exploits::run()
{
	if (!HACKS->weapon)
		return;

	if (current_mode == EXPLOITS_NONE || !enabled())
		return;

	if (std::abs(recharge.last_charge_tick - HACKS->cmd->command_number) < 2)
		return;

	if (!cmd_shift::shifting && recharge.fix_tickbase)
	{
		TICKBASE->store(HACKS->local->tickbase(), HACKS->cmd->command_number, this->limits.double_tap + 1, false);

		recharge.fix_tickbase = false;
		return;
	}

	switch (current_mode)
	{
	case EXPLOITS_DT:
	{
		if (this->reset_dt)
		{
			auto& cl_move = this->cl_move;

			bool shot_finish = false;
			if (HACKS->weapon->item_definition_index() == WEAPON_SSG08 || HACKS->weapon->item_definition_index() == WEAPON_AWP)
			{
				float shot_diff = std::abs(HACKS->weapon->last_shot_time() - HACKS->predicted_time);
				shot_finish = shot_diff >= 0.4f;
			}
			else
			{
				float old_time = HACKS->predicted_time;

				if ((HACKS->weapon->is_pistols() && HACKS->weapon->item_definition_index() != WEAPON_CZ75A) || HACKS->weapon->is_heavy_pistols() || HACKS->weapon->is_sniper())
					HACKS->predicted_time = TICKS_TO_TIME(HACKS->local->tickbase() - ((this->limits.double_tap / 2) + 1));
				else
					HACKS->predicted_time -= TICKS_TO_TIME(this->limits.double_tap);

				shot_finish = RAGEBOT->can_fire();
				HACKS->predicted_time = old_time;
			}

			static int choke{};
			if (!cmd_shift::shifting && shot_finish && !RAGEBOT->working && !choke)
			{
				recharge.start = true;
				recharge.finish = false;
				recharge.charge_ticks = this->limits.recharge;

				this->reset_dt = false;
				this->in_action = false;
			}
			else if (HACKS->cmd->buttons.has(IN_ATTACK))
				this->dt_bullet++;
			else
				choke = HACKS->client_state->choked_commands;

			return;
		}

		auto max_shift_amount = limits.double_tap;
		auto misc_weapon = HACKS->weapon->is_misc_weapon() && !HACKS->weapon->is_knife() && !HACKS->weapon->is_taser();

		if (!HACKS->weapon->is_grenade() && !misc_weapon && (RAGEBOT->is_shooting() || RAGEBOT->firing))
			execute_shift = true;

		if (execute_shift)
		{
			cmd_shift::shift_predicted(HACKS->cmd, &this->first_cmd, max_shift_amount);

			reset_dt = true;
			in_action = true;
			execute_shift = false;
			dt_bullet++;

			defensive.tickbase_choke = 100;
			*HACKS->send_packet = true;

			return;
		}

		auto start_defensive = !misc_weapon && HACKS->weapon->item_definition_index() != WEAPON_REVOLVER
			&& (HACKS->can_peek || g_cfg.rage.air_defensive && (!(HACKS->local->flags().has(FL_ONGROUND))));

		if (start_defensive)
		{
			if (defensive.tickbase_choke == 100)
			{
				tick_to_shift_before = max_shift_amount;
				tick_to_shift = max_shift_amount;
				defensive.tickbase_choke = 0;
			}
			else
			{
				if (defensive.tickbase_choke == 0)
				{
					tick_to_shift_before = 0;
					tick_to_shift = 0;

					*HACKS->send_packet = true;

					TICKBASE->store(HACKS->local->tickbase(), HACKS->cmd->command_number, -max_shift_amount + 1, false);

					++defensive.tickbase_choke;
				}
				else
				{
					tick_to_shift_before = max_shift_amount;
					tick_to_shift = max_shift_amount;

					if (defensive.tickbase_choke == 1 && tick_to_shift && shift_complete)
					{
						*HACKS->send_packet = true;

						TICKBASE->store(HACKS->local->tickbase(), HACKS->client_state->last_outgoing_command + HACKS->client_state->choked_commands + 1,
							max_shift_amount + 1, false);

						shift_complete = false;
					}
						
					if (++defensive.tickbase_choke > max_shift_amount + 1)
						defensive.tickbase_choke = 0;
				}
			}
		}
		else
		{
			defensive.tickbase_choke = 100;
			tick_to_shift = max_shift_amount;
			tick_to_shift_before = max_shift_amount;
		}

		in_action = false;
	}
	break;
	case EXPLOITS_HS:
	{
		tick_to_shift_before = limits.double_tap;

		if (HACKS->weapon->is_misc_weapon() || HACKS->weapon->item_definition_index() == WEAPON_REVOLVER)
		{
			in_action = false;
			return;
		}

		if ((RAGEBOT->firing || RAGEBOT->is_shooting()))
		{
			if (*HACKS->send_packet)
			{
				in_action = true;
				tick_to_shift = limits.hide_shots;

				TICKBASE->store(HACKS->local->tickbase(), HACKS->cmd->command_number, limits.hide_shots + 1, true);
			}
			else
			{
				HACKS->cmd->buttons.remove(IN_ATTACK);
				in_action = false;
			}
		}
		else
		{
			HACKS->cmd->buttons.remove(IN_ATTACK);
			in_action = false;
		}
	}
	break;
	}
}

void c_exploits::shift_clmove(float accumulated_extra_samples, bool final_tick)
{
	if (!HACKS->local || !HACKS->local->is_alive())
		return;

	if (!cl_move.trigger)
		return;

	static auto original = hooker::get_original(&hooks::detour::cl_move);

	cl_move.complete = false;

	while (cl_move.amount >= 0)
	{
		if (*HACKS->send_packet && cl_move.amount >= this->limits.double_tap)
			*HACKS->send_packet = false;

		ENGINE_PREDICTION->update();

		cl_move.shifting = true;
		original(HACKS->global_vars->interval_per_tick, cl_move.amount <= 0);

		cl_move.amount--;
	}

	cl_move.trigger = false;
	cl_move.shifting = false;
	cl_move.complete = true;
}

void write_user_cmd(void* buf, c_user_cmd* in, c_user_cmd* out)
{
	__asm
	{
		mov     ecx, buf
		mov     edx, in
		push    out
		call    offsets::write_user_cmd
		add     esp, 4
	}
}

bool c_exploits::should_shift_cmd(int* new_commands, int* backup_commands, void* ecx, void* edx, int slot, void* buf, int from, int to)
{
	static auto original = hooker::get_original(&hooks::vmt::write_usercmd_to_delta_buffer);

	auto newcmds = *new_commands;
	auto shift_amount = std::clamp(tick_to_shift, 1, limits.recharge);

	shift_complete = false;
	tick_to_shift = 0;
	*backup_commands = 0;

	auto choked_modifier = newcmds + shift_amount;

	if (choked_modifier > 62)
		choked_modifier = 62;

	*new_commands = choked_modifier;

	auto final_from = -1;
	auto next_cmdnr = HACKS->client_state->choked_commands + HACKS->client_state->last_outgoing_command + 1;
	auto final_to = next_cmdnr - newcmds + 1;

	if (final_to <= next_cmdnr)
	{
		while (original(ecx, edx, slot, buf, final_from, final_to, true))
		{
			final_from = final_to++;

			if (final_to > next_cmdnr)
				goto next_cmd;
		}

		return false;
	}
next_cmd:

	auto user_cmd = HACKS->input->get_user_cmd(final_from);

	if (!user_cmd)
		return true;

	c_user_cmd to_cmd{};
	c_user_cmd from_cmd{};

	from_cmd = *user_cmd;
	to_cmd = from_cmd;

	++to_cmd.command_number;
	to_cmd.tickcount = INT_MAX;
	do
	{
		write_user_cmd(buf, &to_cmd, &from_cmd);

		++to_cmd.command_number;
		shift_amount--;
	} while (shift_amount > 0);

	shift_complete = true;
	return true;
}